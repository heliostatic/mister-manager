#!/usr/bin/env bash
#
# secrets
#
# Unified secrets management with multiple password manager backends
# Falls back to macOS Keychain for offline caching
#
# Supported backends:
#   op          1Password CLI       op://Vault/Item/field
#   pass        password-store      path/to/secret
#   bw          Bitwarden CLI       item-name (or UUID)
#   gopass      gopass              path/to/secret
#   secret-tool libsecret           attr1=val1,attr2=val2
#
# Usage:
#   secrets get email/password
#   secrets validate             # Check all secrets are accessible
#   secrets cache-all            # Cache secrets to Keychain (macOS)
#   secrets list                 # Show available secrets

set -e

DOTFILES_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
source "$DOTFILES_ROOT/script/lib.sh"

# =============================================================================
# Secret Definitions
# =============================================================================
# Format: "name|backend:reference"
#
# Backends and reference formats:
#   op          op://VaultName/ItemName/FieldName
#   pass        path/to/secret
#   bw          item-name-or-uuid
#   gopass      path/to/secret
#   secret-tool attr1=val1,attr2=val2
#
# Examples:
#   email/password|op://Personal/Email App Password/password
#   github/token|pass:tokens/github
#   api/key|bw:api-credentials
#   ssh/passphrase|gopass:ssh/id_ed25519
#   db/password|secret-tool:service=mydb,user=admin
#
# To customize, create script/secrets.defs.local with your SECRET_DEFS.
# That file is gitignored and will be sourced automatically.
#

# Default empty (template users should create secrets.defs.local)
SECRET_DEFS=""

# Source local definitions if present (this is where personal secrets go)
if [[ -f "$DOTFILES_ROOT/script/secrets.defs.local" ]]; then
    source "$DOTFILES_ROOT/script/secrets.defs.local"
fi

# Keychain service prefix (for caching)
KEYCHAIN_PREFIX="dotfiles"

# =============================================================================
# Backend Detection
# =============================================================================

# Parse backend from reference (returns "op", "pass", "bw", etc.)
get_backend() {
    local ref="$1"
    if [[ "$ref" == op://* ]]; then
        echo "op"
    elif [[ "$ref" == pass:* ]]; then
        echo "pass"
    elif [[ "$ref" == bw:* ]]; then
        echo "bw"
    elif [[ "$ref" == gopass:* ]]; then
        echo "gopass"
    elif [[ "$ref" == secret-tool:* ]]; then
        echo "secret-tool"
    else
        # Default to 1Password for backwards compatibility
        echo "op"
    fi
}

# Get the reference part (strip backend prefix if present)
get_ref_value() {
    local ref="$1"
    local backend
    backend=$(get_backend "$ref")

    case "$backend" in
        op)
            # op:// references are used as-is
            echo "$ref"
            ;;
        pass|bw|gopass|secret-tool)
            # Strip "backend:" prefix
            echo "${ref#*:}"
            ;;
    esac
}

# Check if a backend CLI is available
check_backend() {
    local backend="$1"
    case "$backend" in
        op)         has_command op ;;
        pass)       has_command pass ;;
        bw)         has_command bw ;;
        gopass)     has_command gopass ;;
        secret-tool) has_command secret-tool ;;
        *)          return 1 ;;
    esac
}

# Get install instructions for a backend
backend_install_hint() {
    local backend="$1"
    case "$backend" in
        op)         echo "brew install 1password-cli" ;;
        pass)       echo "brew install pass  # or: apt install pass" ;;
        bw)         echo "brew install bitwarden-cli  # or: npm install -g @bitwarden/cli" ;;
        gopass)     echo "brew install gopass  # or: apt install gopass" ;;
        secret-tool) echo "apt install libsecret-tools" ;;
    esac
}

# =============================================================================
# Backend-Specific Retrieval
# =============================================================================

get_from_op() {
    local ref="$1"
    op read "$ref" 2>/dev/null
}

get_from_pass() {
    local ref="$1"
    pass show "$ref" 2>/dev/null | head -1
}

get_from_bw() {
    local ref="$1"

    # Check if we have a session
    if [[ -z "$BW_SESSION" ]]; then
        # Try to unlock
        if ! bw unlock --check &>/dev/null; then
            warn "Bitwarden vault is locked. Run: export BW_SESSION=\$(bw unlock --raw)"
            return 1
        fi
    fi

    # Try to get by name or ID
    local item
    item=$(bw get item "$ref" 2>/dev/null)
    if [[ -n "$item" ]]; then
        echo "$item" | jq -r '.login.password // .notes // empty' 2>/dev/null
    else
        return 1
    fi
}

get_from_gopass() {
    local ref="$1"
    gopass show -o "$ref" 2>/dev/null
}

get_from_secret_tool() {
    local ref="$1"
    # ref format: attr1=val1,attr2=val2
    # Bash 3.2 compatible: use a different approach than read -ra
    local args=()
    local oldIFS="$IFS"
    IFS=','
    for pair in $ref; do
        IFS='='
        set -- $pair
        local key="$1"
        local val="$2"
        args+=("$key" "$val")
    done
    IFS="$oldIFS"
    secret-tool lookup "${args[@]}" 2>/dev/null
}

# Unified get from backend
get_from_backend() {
    local name="$1"
    local ref="$2"
    local backend
    backend=$(get_backend "$ref")
    local ref_value
    ref_value=$(get_ref_value "$ref")

    if ! check_backend "$backend"; then
        fail "$backend CLI not installed. Run: $(backend_install_hint "$backend")"
    fi

    case "$backend" in
        op)         get_from_op "$ref_value" ;;
        pass)       get_from_pass "$ref_value" ;;
        bw)         get_from_bw "$ref_value" ;;
        gopass)     get_from_gopass "$ref_value" ;;
        secret-tool) get_from_secret_tool "$ref_value" ;;
        *)          fail "Unknown backend: $backend" ;;
    esac
}

# =============================================================================
# Keychain (Cache Layer)
# =============================================================================

get_from_keychain() {
    local name="$1"
    local service="${KEYCHAIN_PREFIX}-${name//\//-}"

    if [[ "$(uname)" == "Darwin" ]]; then
        security find-generic-password -s "$service" -w 2>/dev/null && return 0
    fi
    return 1
}

save_to_keychain() {
    local name="$1"
    local value="$2"
    local service="${KEYCHAIN_PREFIX}-${name//\//-}"

    if [[ "$(uname)" == "Darwin" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            printf "${GRAY}  [dry-run]${NC} security add-generic-password -s %q -a %q -w ***\n" "$service" "$USER"
            _dryrun_count
            return 0
        fi
        # Delete existing if present
        security delete-generic-password -s "$service" 2>/dev/null || true
        # Add new
        security add-generic-password -s "$service" -a "$USER" -w "$value"
        return 0
    fi
    return 1
}

# =============================================================================
# Secret Definition Helpers
# =============================================================================

# Get reference for a secret name
get_secret_ref() {
    local name="$1"
    echo "$SECRET_DEFS" | while IFS='|' read -r key ref; do
        [[ -z "$key" || "$key" == \#* ]] && continue
        if [[ "$key" == "$name" ]]; then
            echo "$ref"
            return 0
        fi
    done
}

# List all secret names (excluding comments)
list_secret_names() {
    echo "$SECRET_DEFS" | while IFS='|' read -r key ref; do
        [[ -z "$key" || "$key" == \#* ]] && continue
        echo "$key"
    done
}

# Count secrets defined
count_secrets() {
    local count
    count=$(list_secret_names | grep -c . 2>/dev/null) || count=0
    echo "$count"
}

# =============================================================================
# Commands
# =============================================================================

cmd_get() {
    local name="$1"

    if [[ -z "$name" ]]; then
        fail "Usage: secrets get <name>"
    fi

    # Try keychain first (fast, offline)
    local value
    if value=$(get_from_keychain "$name" 2>/dev/null); then
        echo "$value"
        return 0
    fi

    # Get the reference for this secret
    local ref
    ref=$(get_secret_ref "$name")

    if [[ -z "$ref" ]]; then
        fail "Unknown secret: $name (not defined in SECRET_DEFS)"
    fi

    # Try the appropriate backend
    if value=$(get_from_backend "$name" "$ref" 2>/dev/null); then
        echo "$value"
        return 0
    fi

    fail "Could not retrieve secret: $name"
}

cmd_validate() {
    local total=0
    local found=0
    local missing=0
    local missing_items=()
    local backends_used=()

    info "Validating secrets..."
    echo ""

    while IFS='|' read -r name ref; do
        [[ -z "$name" || "$name" == \#* ]] && continue
        ((total++)) || true

        local backend
        backend=$(get_backend "$ref")

        # Track backends used (bash 3.2 compatible)
        local already_tracked=false
        for b in "${backends_used[@]}"; do
            if [[ "$b" == "$backend" ]]; then
                already_tracked=true
                break
            fi
        done
        if [[ "$already_tracked" == false ]]; then
            backends_used+=("$backend")
        fi

        # Check if backend is available
        if ! check_backend "$backend"; then
            warn "SKIP: $name (${backend} CLI not installed)"
            missing_items+=("$name (${backend} not installed)")
            ((missing++)) || true
            continue
        fi

        # Try to retrieve the secret
        if get_from_backend "$name" "$ref" &>/dev/null; then
            verbose "OK: $name ($backend)"
            ((found++)) || true
        else
            warn "MISSING: $name ($backend)"
            missing_items+=("$name")
            ((missing++)) || true
        fi
    done <<< "$SECRET_DEFS"

    echo ""
    printf "  ${GREEN}✓${NC} %d/%d secret(s) accessible\n" "$found" "$total"

    if [[ ${#backends_used[@]} -gt 0 ]]; then
        printf "  ${GRAY}Backends: %s${NC}\n" "${backends_used[*]}"
    fi

    if [[ $missing -gt 0 ]]; then
        printf "  ${YELLOW}⚠${NC} %d secret(s) missing or inaccessible\n" "$missing"
        echo ""
        info "Missing secrets:"
        for item in "${missing_items[@]}"; do
            echo "    - $item"
        done
        return 1
    fi

    success "All secrets validated"
    return 0
}

cmd_cache_all() {
    if [[ "$(uname)" != "Darwin" ]]; then
        fail "Keychain caching is only available on macOS"
    fi

    info "Caching secrets to Keychain..."

    local count=0
    local failed=0
    local skipped=0

    while IFS='|' read -r name ref; do
        [[ -z "$name" || "$name" == \#* ]] && continue

        local backend
        backend=$(get_backend "$ref")

        if [[ "$DRY_RUN" == true ]]; then
            local cached=""
            if get_from_keychain "$name" &>/dev/null; then
                cached=" (already cached, would update)"
            else
                cached=" (would add to keychain)"
            fi
            printf "${GRAY}  [dry-run]${NC} Cache: %s [%s]%s\n" "$name" "$backend" "$cached"
            _dryrun_count
            ((count++)) || true
            continue
        fi

        # Check if backend is available
        if ! check_backend "$backend"; then
            warn "Skipped: $name (${backend} CLI not installed)"
            ((skipped++)) || true
            continue
        fi

        local value
        if value=$(get_from_backend "$name" "$ref" 2>/dev/null); then
            if save_to_keychain "$name" "$value"; then
                success "Cached: $name"
                ((count++)) || true
            else
                warn "Failed to cache: $name"
                ((failed++)) || true
            fi
        else
            warn "Could not retrieve: $name ($backend)"
            ((failed++)) || true
        fi
    done <<< "$SECRET_DEFS"

    if [[ "$DRY_RUN" == true ]]; then
        [[ "$NO_SUMMARY" == true ]] || show_dryrun_summary
    else
        if [[ $failed -gt 0 || $skipped -gt 0 ]]; then
            warn "Cached $count secrets, $failed failed, $skipped skipped"
        else
            success "Cached $count secrets to Keychain"
        fi
    fi
}

cmd_list() {
    local secret_count
    secret_count=$(count_secrets)

    if [[ "$secret_count" -eq 0 ]]; then
        echo "No secrets defined."
        echo ""
        echo "Create script/secrets.defs.local with your SECRET_DEFS:"
        echo "  SECRET_DEFS=\""
        echo "  email/password|op://Personal/Email/password"
        echo "  github/token|pass:tokens/github"
        echo "  \""
        return 0
    fi

    echo "Available secrets:"
    echo ""

    while IFS='|' read -r name ref; do
        [[ -z "$name" || "$name" == \#* ]] && continue

        local backend
        backend=$(get_backend "$ref")
        local cached=""
        local status=""

        if get_from_keychain "$name" &>/dev/null; then
            cached=" (cached)"
        fi

        if ! check_backend "$backend"; then
            status=" [${backend} not installed]"
        fi

        printf "  %-30s %s%s%s\n" "$name" "[$backend]" "$cached" "$status"
    done <<< "$SECRET_DEFS"
}

cmd_backends() {
    echo "Supported password manager backends:"
    echo ""

    # Bash 3.2 compatible: use pipe-delimited strings instead of arrays with ${!arr[@]}
    local backends="op pass bw gopass secret-tool"
    local names="1Password|pass (password-store)|Bitwarden|gopass|secret-tool (libsecret)"
    local formats="op://Vault/Item/field|path/to/secret|item-name-or-uuid|path/to/secret|attr1=val1,attr2=val2"

    local i=1
    local oldIFS="$IFS"
    IFS=' '
    for backend in $backends; do
        local name format installed
        name=$(echo "$names" | cut -d'|' -f$i)
        format=$(echo "$formats" | cut -d'|' -f$i)

        if check_backend "$backend"; then
            installed="${GREEN}✓${NC}"
        else
            installed="${GRAY}○${NC}"
        fi

        # Use %b for all arguments containing ANSI escape sequences
        printf "  %b %-25s %b\n" "$installed" "$name" "${GRAY}${format}${NC}"
        ((i++)) || true
    done
    IFS="$oldIFS"

    echo ""
    echo "Reference format in SECRET_DEFS:"
    echo "  name|backend:reference"
    echo ""
    echo "Examples:"
    echo "  email/password|op://Personal/Email App Password/password"
    echo "  github/token|pass:tokens/github"
    echo "  api/key|bw:api-credentials"
    echo "  ssh/passphrase|gopass:ssh/id_ed25519"
    echo "  db/password|secret-tool:service=mydb,user=admin"
}

cmd_help() {
    cat << 'EOF'
secrets - Unified secrets management with multiple backends

Usage:
  secrets get <name>          Get a secret (tries Keychain cache, then backend)
  secrets validate            Validate all secrets are accessible
  secrets cache-all           Cache all secrets to Keychain (macOS)
  secrets list                List available secrets
  secrets backends            Show supported backends and status

Options:
  -n, --dry-run       Show what would be done (for cache-all)
  --skip-validate     Skip validation before caching
  -h, --help          Show this help

Supported Backends:
  op          1Password CLI       op://Vault/Item/field
  pass        password-store      path/to/secret
  bw          Bitwarden CLI       item-name-or-uuid
  gopass      gopass              path/to/secret
  secret-tool libsecret           attr1=val1,attr2=val2

Configuration:
  Create script/secrets.defs.local with your secrets:

    SECRET_DEFS="
    email/password|op://Personal/Email/password
    github/token|pass:tokens/github
    api/key|bw:api-credentials
    "

  See script/secrets.defs.example for a template.

EOF
    local secret_count
    secret_count=$(count_secrets)
    if [[ "$secret_count" -gt 0 ]]; then
        echo "Defined secrets ($secret_count):"
        list_secret_names | while read -r name; do
            echo "  $name"
        done
    fi
}

# =============================================================================
# Main
# =============================================================================

main() {
    local cmd="${1:-help}"
    shift || true

    # Check for flags anywhere in args
    local args=()
    for arg in "$@"; do
        case "$arg" in
            -n|--dry-run)
                DRY_RUN=true
                export DRY_RUN
                ;;
            --no-summary)
                NO_SUMMARY=true
                ;;
            --skip-validate)
                SKIP_VALIDATE=true
                ;;
            *)
                args+=("$arg")
                ;;
        esac
    done

    case "$cmd" in
        get)        cmd_get "${args[@]}" ;;
        validate)   cmd_validate "${args[@]}" ;;
        cache|cache-all) cmd_cache_all "${args[@]}" ;;
        list)       cmd_list "${args[@]}" ;;
        backends)   cmd_backends "${args[@]}" ;;
        help|-h|--help) cmd_help ;;
        *)          fail "Unknown command: $cmd (try: secrets help)" ;;
    esac
}

main "$@"
